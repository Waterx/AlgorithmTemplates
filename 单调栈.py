
# 单调递增栈示例，若想改为递减栈，内部 while 条件的符号更改即可
# 递增栈感性上可以想肌肉男，上大下小

# 操作规则（下面都以单调递增栈为例）
# 1. 如果新的元素比栈顶元素大，就入栈
# 2. 如果新的元素较小，那就一直把栈内元素弹出来，直到栈顶比新元素小
# 
# 效果：
# 1. 栈内的元素是递增的
# 2. 当元素出栈时，说明这个 新元素 是出栈元素 向后 找第一个比其小的元素
# 3. 当元素出栈后，说明 新栈顶元素 是出栈元素 向前 找第一个比其小的元素
# 如栈 [1,5,6] ， for 到 2 的时候， 2 是 6 向后找第一个比 6 小的 
#                 6 出栈后，5 是 6 向前找第一个比 6 小的
#
# 意义：
# 用 O(n) 复杂度的一重遍历找到每个元素前后最近的更小/大元素位置
#
# 考点：
# 如：在一维数组中对每一个数找到第一个比自己小的元素。（递增栈）
# 这类“在一维数组中找第一个满足某种条件的数”的场景就是典型的单调栈应用场景。

stack = []
for i in range(len(nums)):

    while stack and stack[-1] > nums[i]:
        stack.pop()
        # do something
    
    stack.append(nums[i])

# 例：找到每个数右边第一个比它小的数    （递增栈）
# [10,5,8,12,6]            栈方向：顶 <- 底
# 到10的轮次 [10]
# 到5的轮次  弹10 [5]
# 到8的轮次  [8,5]
# 到12的轮次 [12,8,5]
# 到6的轮次  弹12 12找到6 弹8 8找到6 [6,5]

# *一个元素弹出的时候，谁把它弹出的谁就是下一个小值
# 最后留在栈里是没找到的


# 例：找到每个数右边第一个比它大的数   （递减栈）
# [10,5,8,12,6]           栈方向：顶 <- 底
# 到10的轮次 [10]
# 到5的轮次  [5,10]
# 到8的轮次 *弹5 5找到了8 [8,10]   
# 到12的轮次 *弹8 8找到了12 *弹10 10找到了12 [12] 
# 到6的轮次 [6,12]  

# *一个元素弹出的时候，谁把它弹出的谁就是下一个大值
# 最后留在栈里是没找到的
