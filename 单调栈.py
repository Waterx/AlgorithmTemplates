
# 意义：
# 用 O(n) 复杂度的一重遍历找到每个元素前后最近的更小/大元素位置
#
# 单调栈的作用：
# 以某种规则存放之前遍历过的元素，来保证一次遍历解决问题
#
# 考点：
# 如：在一维数组中对每一个数找到第一个比自己小的元素。（递增栈）
# 这类“在一维数组中找第一个满足某种条件的数”的场景就是典型的单调栈应用场景。
# 
# 心得：
# 单调递增栈示例，若想改为递减栈，内部 while 条件的符号更改即可
# 递增栈感性上可以想肌肉男，上大下小。
# 遍历过程是 当前元素 与 栈顶 的比较；精髓就是以 <出栈元素> 的视角向左向右看！
# 找小递增栈、找大递减栈。（这个想不起来就找两个数模拟）
# 

stack = []
for i in range(len(nums)):

    while stack and stack[-1] > nums[i]:
        stack.pop()
        # do something
    
    stack.append(nums[i])

# 例：找到每个数右边第一个比它小的数    （递增栈）
# [10,5,8,12,6]            栈方向：顶 <- 底
# 到10的轮次 [10]
# 到5的轮次  弹10 [5]
# 到8的轮次  [8,5]
# 到12的轮次 [12,8,5]
# 到6的轮次  弹12 12找到6 弹8 8找到6 [6,5]

# *一个元素弹出的时候，谁把它弹出的谁就是下一个小值
# 最后留在栈里是没找到的


# 例：找到每个数右边第一个比它大的数   （递减栈）
# [10,5,8,12,6]           栈方向：顶 <- 底
# 到10的轮次 [10]
# 到5的轮次  [5,10]
# 到8的轮次 *弹5 5找到了8 [8,10]   
# 到12的轮次 *弹8 8找到了12 *弹10 10找到了12 [12] 
# 到6的轮次 [6,12]  

# *一个元素弹出的时候，谁把它弹出的谁就是下一个大值
# 最后留在栈里是没找到的


# # 深入的理解（递增栈为例）：
# 1. 栈内的元素是递增的
# 2. 当元素出栈时， <当前遍历元素> 是 <出栈元素> 向右 找第一个比其小的元素   （递减栈向右第一个比其大的
# 3. 当元素出栈后， <新栈顶>      是 <出栈元素> 向左 找第一个比其小的元素   （递减栈向左第一个比其大的
# 如栈 [1,5,6] ， for 到 2 的时候， 2 是 6 向后找第一个比 6 小的 
#                 6 出栈后，5 是 6 向前找第一个比 6 小的

# 接雨水和矩形面积的关键是：
# 弹出的一瞬间，<出栈元素> 和 <当前遍历元素>、<新栈顶> 的关系！
# 以 <出栈元素> 的视角看，不考虑上面找大找小的事。
# 精髓就是以 <出栈元素> 的视角向左向右看！